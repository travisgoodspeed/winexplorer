'      Ultra Repair Station unlooper V1               '
'          Public Release 1-30-03                     '
'
'    Awesome results when used with the URS!          '
'
' This is a very simple, basic unlooper script        '
' based entirely on the works of other software.       '
' I will not go on listing everyone that has          '
' contributed the knowledge that makes this           '
' possible because it's a long list! I had planned    '
' on adding a "FF card" option but after testing      '
' this for a long time I couln't see any difference   '
' This script doesn't have any extras like timers     '
' or such, it just unloops cards fast. That's all     '
' anyone wants in the end anyway, right?              '
' So enjoy this and lemme know what ya think.         '
' Take it easy, cracker                               '
'

Option Explicit
    Const dss_DefaultButton1 =0
    Const dss_DefaultButton2 = 256
    Const dss_DefaultButton3 = 512
    Const fsoError = -1
    Const fsoOpenRead = 0
    Const fsoOpenWrite = 1
    Const fsoOpenReadWrite = 2
    Const fsoSEEK_SET = 0
    Const fsoSEEK_CUR = 1
    Const fsoSEEK_END = 2
    Const FileFilter = "All Eprom Files (*.bin, *.crd)|*.bin;*.crd;|Bin Files (*.bin)|*.bin|Crd Files (*.crd)|*.crd|All (*.*)|*.*"
Const Ins = &h08
Const InsParam1 = &h00
Const InsParam2 = &h00
Const InsLen = &h34
Dim OutFile
Dim InFile
Dim HUBinFile
Dim XORedByte(31)
Dim Key12byte(11)
Dim Choice
Dim d0,D1,D2,D3,D4,D5,D6,D7,D8,d9
Dim ScriptStart,ScriptEnd
Dim DAC
Dim DAC4C
Dim Delaye
Dim Delay5C
Dim glttl,Attempts
Dim chglch
Dim glchs
Dim MenuPrompt
Dim Read
Dim Glrngchoice




'On Error

Sub Main()
    Dim ErrorString
    Dim MenuPrompt
    Dim Choice
    Dim PromptString
    Dim RetVal
    Dim GotInput
    Dim ThisChar
    Dim Version
    Dim Password

    Sc.Verbose = 0

    If Sc.Version < 5.0 Then
        ErrorString = "You need version 5.0 or greater of WinExplorer to run this script"
        Sc.MsgBox ErrorString, vbCritical
        Err.Raise 1050, , ErrorString
        End If

    if ChipVer <> 1 then
        sc.MsgBox("You need chip version UL4S to run this script" & VbCr & "Flash your chip with the Included UL4S code")
        Exit Sub
     end if

Do
    MenuPrompt = "              Ultra Unlooper" & vbCrLf & vbCrLf
    MenuPrompt = MenuPrompt & "              THE Unlooper for the URS" & vbCrLf
    Choice = Sc.ButtonBox(MenuPrompt, 0, "Ultra Unlooper","Unloop", "Exit")

    Select Case Choice

    Case "1"
    Call MENU1()
    ' RetVal = 3
     'call IsCardPresent()
     'if(GetATR = True) then
      '   RetVal=Sc.ButtonBox("This card appears to have a good ATR"& VbCr &"Unloop anyway",  vbDefaultButton2 + vbQuestion, "Ultra UL", "Yes", "No")
       '  if RetVal = 1 then RetVal = 3
      'End if

     'if RetVal = 3 then

      ' HUBinfile = False
    'if(BootCard())= 1 then
     '  sc.print VbCr & "Select a good eeprom bin to write to the card" & VbCr
      ' Call GetFile()

       'If HUBinFile = True then
        '    Call WriteCard()
         '   call ShowAtr()
          'else
           ' Fs.FileClose(InFile)
          'end if

        ' end if
       'end if


    Case "2", ""
        Exit Sub
        Case Else
            MenuPrompt = "Invalid Input!" & vbCrLf
    End Select
    Loop While True = True

end sub


Sub GetFile()

    Dim FileName
    Dim FileSize

    FileName = Fs.FileOpenDialog(FileFilter, "    Please select a valid HU Eprom (*.bin) file to write to the card", "Default.bin")
    If FileName <> "" Then
        If Fs.FileExists(FileName) = 0 Then
            Sc.MsgBox("The file does not exist")
        Else
            InFile = Fs.FileOpen(FileName, fsoOpenRead)
        End If
    End If

    FileSize = Fs.FileSeek(InFile, 0, fsoSEEK_END)

    If FileSize <> "8192" Then
        Sc.MsgBox("This file is NOT a valid HU bin file" & vbcr & "or the bin file you are trying to open" & vbcr & "is being used by another program")
        HUBinFile = False
        Exit Sub
    Else
        HUBinFile = True
    End If

End Sub

Sub GetFileName()
    Dim FileName

    FileName = Fs.FileSaveDialog(FileFilter, "Please select a name for the new bin file", "Default.bin")
    If FileName <> "" Then
        OutFile = Fs.FileCreate(FileName)
    end if
end sub

Sub GetFile()
    Dim FileName
    Dim FileSize

    FileName = Fs.FileOpenDialog(FileFilter, "Please select a valid HU Eprom (*.bin) file", "Default.bin")
    If FileName <> "" Then
        If Fs.FileExists(FileName) = 0 Then
            Sc.MsgBox("The file does not exist")
        Else
            InFile = Fs.FileOpen(FileName, fsoOpenRead)
        End If
    End If

    FileSize = Fs.FileSeek(InFile, 0, fsoSEEK_END)
    'Sc.Print "The file size is " & FileSize & vbCr

    if FileSize <> "8192" then
    Sc.MsgBox("This file is NOT a valid HU bin file" & vbcr & "or the bin file you are trying to open" & vbcr & "is being used by another program")
    HUBinFile = False
    exit sub
    else
    HUBinFile = True
    end if

end sub

Sub WriteCard()
    Dim EPROM
    Dim ThisByte
    Dim Address
    Dim RetValue
    Dim Location
    Dim EPROMBytes
    Dim EPROMBytes2

    Address = 8192
    Location = 0

Sc.Write("A2")

'Call WDTMR()

'call Fs.FileSeek(InFile, 0, fsoSEEK_SET)
'EPROMBytes = ""
'For ThisByte = 20 to (22) - 1
'EPROMBytes = EPROMBytes & HexString(Fs.FileGetc(InFile), 2)
'Next
'Sc.Write("07C4812014" & EPROMBytes & "00")
'Sc.Read(&h02)
'Sc.Print "2014: " & EPROMBytes & vbcr

Call Sc.ProgressBox ("Writing EPROM memory..." & vbcr & "2000:  " & EPROMBytes, EPROM, 255, "Ultra UL")


call Fs.FileSeek(InFile, Location, fsoSEEK_SET)

Do

Call WDTMR()

EPROMBytes = ""
For ThisByte = Location to (Location + 16) - 1
EPROMBytes = EPROMBytes & HexString(Fs.FileGetc(InFile), 2)
Next
EPROMBytes2 = ""
For ThisByte = (Location + 16) to (Location + 32) - 1
EPROMBytes2 = EPROMBytes2 & HexString(Fs.FileGetc(InFile), 2)
Next

Sc.Write("25E29F" & HexString(Address,4) & EPROMBytes & EPROMBytes2 & "00")
Sc.Read(&h02)
Call Sc.ProgressBox ("Writing EPROM memory..." & vbcr & HexString(Address,4) & ":  " & EPROMBytes & vbcr & HexString(Address + 16,2) & ":  " & EPROMBytes2, EPROM, 255, "Ultra UL")

EPROM = EPROM + 1
Address = Address + 32
Location = Location + 32
loop until EPROM = 255

Fs.FileClose(InFile)
Sc.Write("A0")                ' turn the LED off
Sc.Write("020200")
Sc.Delay(100)
Sc.Read(&h02)

Call Sc.ProgressBox ("", 0, 0, "")

end sub

Sub WriteThruBootStrap(Address, Bytes, Note, CurrentNumber, TotalNumber)
'Write Thru Boot Strap routine enables easy writing to the card
'after boot strap is loaded by providing the ability to specify
'a note for ProgressBox and it's counters, address location
'and the actual bytes to write. Bytes to write must NOT
'contain spaces so that they can be automatically calculated.
'You may write up to 64 bytes at one time.
'Example with a note:
'Call WriteThruBootStrap("2080", "FFFFFFFF", "Writing to EPROM..., 1, 1)
'Example without a note:
'Call WriteThruBootStrap("2080", "FFFFFFFF", "", "", "")
    Dim DecNumberOfBytesInGlitchPacket
    Dim HexNumberOfBytesInGlitchPacket
    Dim HexNumberOfBytesToTransmit
    Dim HexNumberOfBytesToWrite

    DecNumberOfBytesInGlitchPacket = 9 + (Len(Bytes))/2
    If DecNumberOfBytesInGlitchPacket < &h10 Then
        HexNumberOfBytesInGlitchPacket = "0" & Hex(DecNumberOfBytesInGlitchPacket)
    Else
        HexNumberOfBytesInGlitchPacket = Hex(DecNumberOfBytesInGlitchPacket)
    End If
    HexNumberOfBytesToWrite = Hex(118 + DecNumberOfBytesInGlitchPacket)
    HexNumberOfBytesToTransmit = Hex(182 + DecNumberOfBytesInGlitchPacket)
    If Note <> "" or CurrentNumber <> "" or TotalNumber <> "" then
    Call Sc.ProgressBox (Note, CurrentNumber, TotalNumber, "Ultra UL")
    else
    end if
Sc.Write(HexNumberOfBytesInGlitchPacket & "C2" & HexNumberOfBytesToWrite & Address & HexNumberOfBytesToTransmit & Bytes & "0EFF8000")
Sc.Read(&h03)
End Sub

Sub WDTMR()
    Dim RetValue

Sc.Write("05150E108000")'SET WDTMR
sc.delay(70)
Sc.Read(&h02)
        RetValue = Sc.GetByte(&h01)
        Sc.Read(RetValue)
end sub

Sub IsCardPresent()
    Dim RetValue
    Dim GotInput
Do
Sc.Write("A0")                ' turn the LED off
Sc.Write("80")                'Is card present?
Sc.Delay(100)
If Sc.BytesInBuffer > 0 then
Sc.Read(&h01)
RetValue = Sc.GetByte(0)
end if

If RetValue = &h0 then
Call Sc.ProgressBox ("*** Please insert your card... ***", 1, 999, "Ultra UL")
GotInput = False
else
If RetValue = &hFF then
GotInput = True
else
If RetValue <> &h0 or RetValue <> &hFF then
Sc.Write("A0")                ' turn the LED off
Sc.Write("020200")
Sc.Delay(100)
If Sc.BytesInBuffer > 1 then
Sc.Read(&h02)
GotInput = False
else
GotInput = False
end if
end if
End if
End if
Loop Until GotInput = True
end sub

Function HexString(Number,Length)
    ' This function takes 2 arguments, a number and a length.  It converts the decimal
    ' number given by the first argument to a Hexidecimal string with its length
    ' equal to the number of digits given by the second argument
    Dim RetVal
    Dim CurLen
    RetVal=Hex(Number)
    CurLen=Len(RetVal)
    If CurLen<Length Then
        RetVal=String(Length-CurLen,"0") & RetVal
    End If
    HexString=RetVal
End Function

Function Hex2Dec(HexNumber)
    ' This function takes 1 argument, a string containing a hex value of any digit length
    ' and returns the decimal equivalent
    Dim DecimalValue
    Dim DigitCount
    Dim Digit
    Dim HexDigit

    HexNumber = Replace(UCase(HexNumber), " ", "")
    DigitCount = Len(HexNumber)

    For Digit = 1 To DigitCount

        HexDigit = Mid(HexNumber, Digit, 1)
        If Asc(HexDigit) < 58 Then
            DecimalValue = HexDigit * 16 ^ (DigitCount - Digit)
        Else
            DecimalValue = (Asc(HexDigit) - 55) * 16 ^ (DigitCount - Digit)
        End If
        Hex2Dec = Hex2Dec + DecimalValue
    Next


End Function



Function GetATR ()

    Dim temp

    Call Sc.ProgressBox(0,0,0,0)
    Sc.Write("06100E10019300")
    Sc.Delay(500)
    Sc.Read(&h02)
    temp = Sc.GetByte(&h01)
    Sc.Read (temp)

    if(temp <> 20) then
        GetATR = False
    else
        GetATR = True
    end if

End Function



Sub RndGr

    Dim g1,g2,g3,g4,g5,g6
    Dim dly,v

RANDOMIZE TIMER

 ' sc.print VbCr & "Random gliching the card to whip it into shape" & VbCr
  sc.verbose = false

  for v = 1 to 800
    g1 = INT(RND * &hFF)
    g2 = INT(RND * &hFF)
    g3 = INT(RND * &hFF)
    g4 = INT(RND * &hFF)
    g5 = INT(RND * &hFF)
    g6 = INT(RND * &h4F) + &h80
    dly= INT(RND * &h200)

    sc.write("B0" & HexString(g6,2))

    sc.write("111f0120" & HexString(dly,4) & "0c" & HexString(g1,2) & "0c" & HexString(g2,2) & "0a" & "0c" & HexString(g3,2) & "0c" & HexString(g4,2) & "0c" & HexString(g5,2) & "00")
    sc.read(2)
  next

End Sub

Sub CardIsLooped ()
Sc.MsgBox("Card is not returning an ATR." &VbCr & "The card may not be fully Inserted" & VbCr &" or the card contacts may be dirty." & VbCr & "If everything is ok then the card is looped"&VbCr& "You must Unloop the card before using this option ")

End Sub


Sub ProgUpdate(pg,atrlock)

    Dim i
    Dim Msg

    Msg="GLITCH RESPONSE INDICATOR"

    if atrlock = 1 then
      Msg=Msg+VbCr+VbCr+"Accessing Card."
    else
      Msg=Msg+VbCr+VbCr+"Glitching."
    end if

    Call Sc.ProgressBox(Msg,pg,33,"Ultra UL")

End Sub

Function Chk4Card()

    Dim tmp
    sc.write("80")
    sc.delay(10)
  if sc.read(1) = 1 then
    tmp=sc.getbyte(0)
    If tmp = &h0 then
        Chk4Card=0
        sc.write("A0")
        Call Sc.ProgressBox(0,0,0,0)
        sc.MsgBox("Why did ya pull the card out?")
    else
        Chk4Card=1
    end if
  end if

End Function

Function ChipVer()

    ChipVer = 1

    sc.write("90")
    delay(80)

    if sc.read(4) <> 4 then
        ChipVer = 0
        Exit Function
     end if

    if getbyte(0) <> &h55 then ChipVer = 0
    if getbyte(1) <> &h4c then ChipVer = 0
    if getbyte(2) <> &h34 then ChipVer = 0
    if getbyte(3) <> &h53 then ChipVer = 0

End Function

''''''''''''''''''''''''''''''''''unloop
SUB MENU1()
    Dim ErrorString
    Dim MenuPrompt
    Dim Choice
    Dim PromptString
    Dim RetVal
    Dim GotInput
    Dim ThisChar
    Dim Version
    Dim Password


    MenuPrompt = "              URS Ultra Unlooper" & vbCrLf & vbCrLf
    MenuPrompt = MenuPrompt & "              Ultra UL" & vbCrLf
    Choice = Sc.ButtonBox(MenuPrompt, 1, "THE Unlooper for the URS", "Unloop V1", "Unloop V2", "Unloop V3", "Unloop V4",  "Exit")

Select Case Choice


CASE"1"
RetVal = 3
     call IsCardPresent()
     if(GetATR = True) then
         RetVal=Sc.ButtonBox("This card appears to have a good ATR"& VbCr &"Unloop anyway",  vbDefaultButton2 + vbQuestion, "Ultra UL", "Yes", "No")
         if RetVal = 1 then RetVal = 3
      End if

     if RetVal = 3 then

       HUBinfile = False
    if(BootCard2())= 1 then
       sc.print VbCr & "Select a good eeprom bin to write to the card" & VbCr
       Call GetFile()

       If HUBinFile = True then
            Call WriteCard()
            call ShowAtr()
          else
            Fs.FileClose(InFile)
          end if

         end if
       end if





CASE"2"
RetVal = 3
     call IsCardPresent()
     if(GetATR = True) then
         RetVal=Sc.ButtonBox("This card appears to have a good ATR"& VbCr &"Unloop anyway",  vbDefaultButton2 + vbQuestion, "Ultra UL", "Yes", "No")
         if RetVal = 1 then RetVal = 3
      End if

     if RetVal = 3 then

       HUBinfile = False
    if(BootCard3())= 1 then
       sc.print VbCr & "Select a good eeprom bin to write to the card" & VbCr
       Call GetFile()

       If HUBinFile = True then
            Call WriteCard()
            call ShowAtr()
          else
            Fs.FileClose(InFile)
          end if

         end if
       end if


CASE"3"
RetVal = 3
     call IsCardPresent()
     if(GetATR = True) then
         RetVal=Sc.ButtonBox("This card appears to have a good ATR"& VbCr &"Unloop anyway",  vbDefaultButton2 + vbQuestion, "Ultra UL", "Yes", "No")
         if RetVal = 1 then RetVal = 3
      End if

     if RetVal = 3 then

       HUBinfile = False
    if(BootCard4())= 1 then
       sc.print VbCr & "Select a good eeprom bin to write to the card" & VbCr
       Call GetFile()

       If HUBinFile = True then
            Call WriteCard()
            call ShowAtr()
          else
            Fs.FileClose(InFile)
          end if

         end if
       end if



CASE"4"
RetVal = 3
     call IsCardPresent()
     if(GetATR = True) then
         RetVal=Sc.ButtonBox("This card appears to have a good ATR"& VbCr &"Unloop anyway",  vbDefaultButton2 + vbQuestion, "Ultra UL", "Yes", "No")
         if RetVal = 1 then RetVal = 3
      End if

     if RetVal = 3 then

       HUBinfile = False
    if(BootCard5())= 1 then
       sc.print VbCr & "Select a good eeprom bin to write to the card" & VbCr
       Call GetFile()

       If HUBinFile = True then
            Call WriteCard()
            call ShowAtr()
          else
            Fs.FileClose(InFile)
          end if

         end if
       end if


CASE"5"
Exit Sub
        Case Else
            MenuPrompt = "Invalid Input!" & vbCrLf
    End Select
    'Loop While True = True

end sub



Sub UnlooperSettings()
    Wx.BaudRate=115200
    Wx.ResetBaudRate=115200
    Wx.Parity=0                  ' 0 = None, 1 = Odd, 2 = Even, 3 = Mark, 4 = Space
    Wx.StopBits=0                ' 0 = 1 stop bit, 1 = 1.5 stop bits, 2 = 2 stop bits
    Wx.DTRControl=0              ' Initial state of DTR  0 = off, 1 = on
    Wx.RTSControl=1              ' Initial state of RTS  0 = off, 1 = on
    Wx.ResetDelay=900           ' In microseconds
    Wx.ByteDelay=900            ' In microseconds
    Wx.RxByteTimeout=400         ' In milliseconds
    Wx.ResetMode=2               ' 0 = No Resets, 1 = ISO Reset (Expect a ATR), 2 = Device Reset (No ATR)
    Wx.ResetLine=1               ' 0 = Toggle RTS for Reset, 1 = Toggle DTR for Reset
    Wx.ByteConvention=1          ' 0 = Inverse, 1 = Direct
    Wx.FlushEchoByte=0           ' 0 = no flush, 1 = flush - A Phoenix interface will echo each byte transmitted.
    Wx.FlushBeforeWrite=0        ' 0 = no flush, 1 = flush - Flush the receive buffer before each write to strip off Null bytes.
    Wx.IgnoreTimeouts=1          ' 0 = Abort script on a receive timeout, 1 = Ignore all receive timeouts
    Wx.ResetAfterTimeout=0       ' 0 = Don't reset after a timeout, 1 = do a reset after a timeout  - Not used if "IgnoreTimeouts=0"
    Wx.LogTransactions=0         ' 0 = Don't log transactions, 1 = log transactions
    Wx.DisplayUSW=0              ' Display USW after script complete 0 = no, 1 = yes
    Wx.DisplayFuse=0             ' Display Fuse after script complete 0 = no, 1 = yes
End Sub


Function BootStrap()
    Sc.Verbose = False
    Dim RetValue

    BootStrap = False
    Sc.Write("0915C448" & HexString(Ins,2) & HexString(InsParam1,2) & HexString(InsParam2,2) & HexString(InsLen,2) & "8000")
    Sc.Delay(80)
    Sc.Read(&h02)
    RetValue = Sc.GetByte(&h01)
    If RetValue > 0 Then
        Sc.Read (RetValue)
        If Sc.GetByte(0) = &h84 Then
            Sc.Write("42FF225272FF14E1E2D007E2D029E2D02A77800718753F07D307D807C5E2AB0060C3DA07F8726015D404E700D57640070DD3078ECEFB70012ADA07F700C49E2A00FA00")
            Sc.Delay(80)
            Sc.Read(&h02)
            BootStrap = True
         End If
    End If
End Function


Sub WriteViaLoader(address,data,options)

    ' Write up to 32 bytes at a time

    Dim dLen
    Dim tlen
    Dim parm1
    Dim parm2
    Dim i,t
    Dim datalen
    Dim addresslow
    Dim tmp
    Dim Xored
    Dim datarray(31)
    Dim datalength

    dLen = Len(data)
    dLen = dLen / 2
    tLen = Len(data)
    tLen = tlen + 16
    tLen = tlen / 2
    tLen = HexString(tlen,2)
    parm1 = Hex(dLen + &hC2)
    parm2 = Hex(dLen + &h7F)

    If Ucase(options) = "E" Then

        'Convert and Split up data String to an array

        t = 0
        For i = 1 To Len(data) Step 2
            tmp = Mid(data, i, 2)
            datarray(t) = (HexToDec(tmp))
            t = (t + 1)
        Next

        addresslow = HexToDec(Mid(address, 3, 2))     'Get lower byte for offset
        addresslow = (addresslow And &h7)             'Strip bits for offset 0-7

        If UBound(datarray) > 32 Then
            Exit Sub
        End If

        datalength = (Len(data) / 2)

        'Encrypt
        t = 0
        For i = addresslow To datalength + addresslow - 1
                Xored = Xored & HexString(datarray(t) Xor HexToDec(XoredByte(i)), 2)
            t = (t + 1)
        Next

        data = Xored
    End if

    Sc.Write(tLen & " " & parm1 & " " & parm2 & " " & address & " " & data & " " & "0EFF8000")
    Sc.Read(&h03)

End Sub

Function HexToDec(HexNumber)

    ' This function takes a string as input, assuming it to be a Hexidecimal string,
    ' and converts it to a decimal number.

    HexNumber=Replace(UCase(HexNumber)," ","")
    HexToDec=CLng("&H"+HexNumber)

End Function


Sub Card_Reset()
    Dim RetVal
    Sc.Write("A0")     ' Turn the LED off if it is on
    Sc.Write("020200") ' Power down the card
    Sc.Delay(1000)     ' Wait about 1 second
    Call Sc.Reset()    ' Power up the card
    RetVal=Sc.Flush()  ' Flush the receive buffer
End Sub

''''''''''''''''''''''''''''''Unlooping
'Bootcard for unlooping
'
Function BootCard2()
Call Card_Reset()
    Dim d0,D1,D2,D3,D4,D5,D6,D7,D8,d9
    Dim cnt,b, RetVal, boot, kk,katr
    Dim atrlock,cter, glcnt, mtries,kp

    RANDOMIZE TIMER

    atrlock=0
    cter=0
    glcnt=0
    mtries = 0
    d0 = 0
    sc.verbose = False

DO
  katr=0
  mtries = mtries + 1
    if mtries = 5000 then
       call RndGr()
       mtries = 0
    end if

    boot = 0
'==============================================
        'vcc + last 2 glitch 4 bootloader
        D2 = INT(RND * &h04) + &h30      ' 48 -  52
        D3 = INT(RND * &h03) + &h08      '  8 -  11
        D4 = INT(RND * &h10) + &h86      '134 - 150
        D9 = INT(RND * &h02) + &h35e     '862 - 864
        '==========================================
        ' Atr glich point search range

       if atrlock = 0 then
        D7 = INT(RND * &h04) + &h1d   ' 29 -  33
        D8 = INT(RND * &h04) + &h38   ' 56 -  60
        D1 = INT(RND * &h5e) + &ha0   '165 - 191
        D5 = INT(RND * &h02) + &h25d  '605 - 607
        D6 = INT(RND * &h07) + &h36   ' 54 -  61

    end if

    call ProgUpdate(kp,atrlock)

    sc.verbose = 0
    sc.write("A1")
    delay(10)

    if Chk4Card() = 0 then
        BootCard2=0
        Exit Function
    end if

    delay(30)

    sc.write("B0" & HexString(D1,02))
    sc.write("0f1f0120" & HexString(D5,4) & "0c" & HexString(D7,2) & "20" & HexString(D6,4) & "0d00" & HexString(D8,2) & "0000")

    Sc.Read(&h02)

    cter=cter+1
    cnt=0
    Sc.Write("028000")
    if Sc.Read(&h02) = 2 then
         cnt = sc.getbyte(1)
    if cnt = 1 then sc.read(1)
    end if

    if cter > 75 then
        glcnt = glcnt + 1
        if glcnt = 24 then
          glcnt = 0
          call RndGr()
        end if
        cter = 0
        atrlock = 0
    end if

    if cnt > 0 then
       kp=kp+1
       if kp >33 then kp = 33
        sc.print "============================================"&VbCr&"ATR"&VbCr
         for b = 0 to 10
         Sc.Write("028000")

         if Sc.Read(&h02) = 2 then
            cnt = sc.getbyte(1)
         else
            cnt = 0
         end if

         if cnt > 0 then
            cnt = sc.read(cnt)
            kk=sc.getbyte(0)
            if kk = &h38 then
               sc.print "38 "
               Sc.Write("028000")
               cnt = 0
               if Sc.Read(&h02) = 2 then
                   cnt = sc.getbyte(1)
                   if(cnt = 0) then exit for
                      Sc.Read(cnt)
                      if(sc.getbyte(0)) = &hb0 then
                         sc.print "B0" & VbCr & "Attempting to install bootloader "
                         d0=d0+1
                         katr=1
                         cter = 0
                         glcnt = 0
                         atrlock =1
                         exit for
                       end if
                    end if
              end if
         end if

      sc.print HexString(kk,2) &" "
      next
      sc.print VbCr &"============================================"&VbCr
      'sc.print VbCr & cter & VbCr

    if katr = 1 then
       sc.write("B0"  & HexString(D4,02))
       sc.write("071f800d" & HexString(D3,02)& HexString(D2,02)&"0000")
       if Sc.Read(&h02) > 1 then
          cnt = sc.getbyte(1)
       else
          cnt = 0
       end if

       if cnt > 0 then
          cnt = sc.read(cnt)
          for b = 0 to cnt - 1
          next

          Sc.Write("31eeFFFFfed18d52E0FD2266E1B9E17201CF725f0772FF14C5E2AB0100C3DA07F88C0100FFFFFFFFFFFFFFFFFFFFFFFF0000")
          if Sc.Read(&h02)<2 then Sc.Read(&h02)
             Sc.Write("11c060200350042001500320" & HexString(D9,04) & "0d010000")
             Sc.Read(&h02)

          for b = 0 to 8
            Sc.Write("028000")
                        if Sc.Read(&h02) = 2 then
                cnt = sc.getbyte(1)
            else
                cnt = 0
            end if

          if cnt > 0 then
             cnt = sc.read(cnt)
             kk=sc.getbyte(0)
             if kk = &h66 then
                Sc.Write("028000")
                cnt = 0
                if Sc.Read(&h02) = 2 then
                   cnt = sc.getbyte(1)
                   if(cnt = 0) then exit for
                      Sc.Read(cnt)
                      if(sc.getbyte(0)) = &h99 then
                         boot=1
                         sc.print VbCr & "Bootloader installed and active!" & VbCr
                         sc.print "After " & d0 & " tries to activate bootloader" &VbCr
                         exit for
                      end if
                    end if
                 end if
             else
                exit for
          end if

         next

        if boot = 1 then
           Sc.Write("021500")
           Sc.Read(2)
           Sc.Write("42FF225272FF14E1E2D007E2D029E2D02A77800716753F07D307F75011E29B2A70012ADA07F78E013A00D7D307D8078ECEFBD40770012ADA07F300C6F76211F7631100")
           Sc.Read(2)
           Sc.Write("21DE8E0149F76011F76111881c931270FF1203FBF70011728512DA12FDF70011F900")
           Sc.Read(2)
           BootCard2=1
           Exit Function
         end if
       end if
     end if
   else
    kp=kp-1
    if kp<1 then kp=1
   end if
loop

End Function


Sub RndGr

    Dim g1,g2,g3,g4,g5,g6
    Dim dly,v

RANDOMIZE TIMER

  sc.print VbCr & "Random gliching the card to whip it into shape" & VbCr
 sc.verbose = false

  for v = 1 to 800
    g1 = INT(RND * &hFF)
    g2 = INT(RND * &hFF)
    g3 = INT(RND * &hFF)
    g4 = INT(RND * &hFF)
    g5 = INT(RND * &hFF)
    g6 = INT(RND * &h4F) + &h80
    dly= INT(RND * &h200)

   ' sc.write("B0" & HexString(g6,2))
'
    sc.write("111f0120" & HexString(dly,4) & "0c" & HexString(g1,2) & "0c" & HexString(g2,2) & "0a" & "0c" & HexString(g3,2) & "0c" & HexString(g4,2) & "0c" & HexString(g5,2) & "00")
    sc.read(2)
  next

End Sub

Sub CardIsLooped ()
Sc.MsgBox("Card is not returning an ATR." &VbCr & "The card may not be fully Inserted" & VbCr &" or the card contacts may be dirty." & VbCr & "If everything is ok then the card is looped"&VbCr& "You must Unloop the card before using this option ")

End Sub

''''''''''''''''''''''''''''''Unlooping
'Bootcard for unlooping
'
Function BootCard3()
Call Card_Reset()
    Dim d0,D1,D2,D3,D4,D5,D6,D7,D8,d9
    Dim cnt,b, RetVal, boot, kk,katr
    Dim atrlock,cter, glcnt, mtries,kp

    RANDOMIZE TIMER

    atrlock=0
    cter=0
    glcnt=0
    mtries = 0
    d0 = 0
    sc.verbose = False

DO
  katr=0
  mtries = mtries + 1
    if mtries = 5000 then
       call RndGr()
       mtries = 0
    end if

    boot = 0
'==============================================
        'vcc + last 2 glitch 4 bootloader
        D2 = INT(RND * &h04) + &h30      ' 48 -  52
        D3 = INT(RND * &h03) + &h08      '  8 -  11
        D4 = INT(RND * &h10) + &h86      '134 - 150
        D9 = INT(RND * &h02) + &h35e     '862 - 864
        '==========================================
        ' Atr glich point search range

       if atrlock = 0 then
        D7 = INT(RND * &h04) + &h1d   ' 29 -  33
        D8 = INT(RND * &h04) + &h38   ' 56 -  60
        D1 = INT(RND * &h5e) + &ha0   '165 - 191
        D5 = INT(RND * &h02) + &h25d  '605 - 607
        D6 = INT(RND * &h07) + &h36   ' 54 -  61

    end if

    call ProgUpdate(kp,atrlock)

    sc.verbose = 0
    sc.write("A1")
    delay(10)

    if Chk4Card() = 0 then
        BootCard3=0
        Exit Function
    end if

    delay(30)

    sc.write("B0" & HexString(D1,02))
    sc.write("0f1f0120" & HexString(D5,4) & "0c" & HexString(D7,2) & "20" & HexString(D6,4) & "0d00" & HexString(D8,2) & "0000")

    Sc.Read(&h02)

    cter=cter+1
    cnt=0
    Sc.Write("028000")
    if Sc.Read(&h02) = 2 then
         cnt = sc.getbyte(1)
    if cnt = 1 then sc.read(1)
    end if

    if cter > 75 then
        glcnt = glcnt + 1
        if glcnt = 24 then
          glcnt = 0
          call RndGr()
        end if
        cter = 0
        atrlock = 0
    end if

    if cnt > 0 then
       kp=kp+1
       if kp >33 then kp = 33
        sc.print "============================================"&VbCr&"ATR"&VbCr
         for b = 0 to 10
         Sc.Write("028000")

         if Sc.Read(&h02) = 2 then
            cnt = sc.getbyte(1)
         else
            cnt = 0
         end if

         if cnt > 0 then
            cnt = sc.read(cnt)
            kk=sc.getbyte(0)
            if kk = &h38 then
               sc.print "38 "
               Sc.Write("028000")
               cnt = 0
               if Sc.Read(&h02) = 2 then
                   cnt = sc.getbyte(1)
                   if(cnt = 0) then exit for
                      Sc.Read(cnt)
                      if(sc.getbyte(0)) = &hb0 then
                         sc.print "B0" & VbCr & "Attempting to install bootloader "
                         d0=d0+1
                         katr=1
                         cter = 0
                         glcnt = 0
                         atrlock =1
                         exit for
                       end if
                    end if
              end if
         end if

      sc.print HexString(kk,2) &" "
      next
      sc.print VbCr &"============================================"&VbCr
      'sc.print VbCr & cter & VbCr

    if katr = 1 then
       sc.write("B0"  & HexString(D4,02))
       sc.write("071f800d" & HexString(D3,02)& HexString(D2,02)&"0000")
       if Sc.Read(&h02) > 1 then
          cnt = sc.getbyte(1)
       else
          cnt = 0
       end if

       if cnt > 0 then
          cnt = sc.read(cnt)
          for b = 0 to cnt - 1
          next

          Sc.Write("31eeFFFFfed18d52E0FD2266E1B9E17201CF725f0772FF14C5E2AB0100C3DA07F88C0100FFFFFFFFFFFFFFFFFFFFFFFF0000")
          if Sc.Read(&h02)<2 then Sc.Read(&h02)
             Sc.Write("11c060200350042001500320" & HexString(D9,04) & "0d010000")
             Sc.Read(&h02)

          for b = 0 to 8
            Sc.Write("028000")
                        if Sc.Read(&h02) = 2 then
                cnt = sc.getbyte(1)
            else
                cnt = 0
            end if

          if cnt > 0 then
             cnt = sc.read(cnt)
             kk=sc.getbyte(0)
             if kk = &h66 then
                Sc.Write("028000")
                cnt = 0
                if Sc.Read(&h02) = 2 then
                   cnt = sc.getbyte(1)
                   if(cnt = 0) then exit for
                      Sc.Read(cnt)
                      if(sc.getbyte(0)) = &h99 then
                         boot=1
                         sc.print VbCr & "Bootloader installed and active!" & VbCr
                         sc.print "After " & d0 & " tries to activate bootloader" &VbCr
                         exit for
                      end if
                    end if
                 end if
             else
                exit for
          end if

         next

        if boot = 1 then
           Sc.Write("021500")
           Sc.Read(2)
           Sc.Write("42FF225272FF14E1E2D007E2D029E2D02A77800716753F07D307F75011E29B2A70012ADA07F78E013A00D7D307D8078ECEFBD40770012ADA07F300C6F76211F7631100")
           Sc.Read(2)
           Sc.Write("21DE8E0149F76011F76111881c931270FF1203FBF70011728512DA12FDF70011F900")
           Sc.Read(2)
           BootCard3=1
           Exit Function
         end if
       end if
     end if
   else
    kp=kp-1
    if kp<1 then kp=1
   end if
loop

End Function


Sub RndGr

    Dim g1,g2,g3,g4,g5,g6
    Dim dly,v

RANDOMIZE TIMER

  sc.print VbCr & "Random gliching the card to whip it into shape" & VbCr
 sc.verbose = false

  for v = 1 to 800
    g1 = INT(RND * &hFF)
    g2 = INT(RND * &hFF)
    g3 = INT(RND * &hFF)
    g4 = INT(RND * &hFF)
    g5 = INT(RND * &hFF)
    g6 = INT(RND * &h4F) + &h80
    dly= INT(RND * &h200)

   ' sc.write("B0" & HexString(g6,2))
'
    sc.write("111f0120" & HexString(dly,4) & "0c" & HexString(g1,2) & "0c" & HexString(g2,2) & "0a" & "0c" & HexString(g3,2) & "0c" & HexString(g4,2) & "0c" & HexString(g5,2) & "00")
    sc.read(2)
  next

End Sub

Sub CardIsLooped ()
Sc.MsgBox("Card is not returning an ATR." &VbCr & "The card may not be fully Inserted" & VbCr &" or the card contacts may be dirty." & VbCr & "If everything is ok then the card is looped"&VbCr& "You must Unloop the card before using this option ")

End Sub

''''''''''''''''''''''''''''''Unlooping
'Bootcard for unlooping
'
Function BootCard4()
Call Card_Reset()
    Dim d0,D1,D2,D3,D4,D5,D6,D7,D8,d9
    Dim cnt,b, RetVal, boot, kk,katr
    Dim atrlock,cter, glcnt, mtries,kp

    RANDOMIZE TIMER

    atrlock=0
    cter=0
    glcnt=0
    mtries = 0
    d0 = 0
    sc.verbose = False

DO
  katr=0
  mtries = mtries + 1
    if mtries = 5000 then
       call RndGr()
       mtries = 0
    end if

    boot = 0
'==============================================
        'vcc + last 2 glitch 4 bootloader
        D2 = INT(RND * &h04) + &h30      ' 48 -  52
        D3 = INT(RND * &h03) + &h08      '  8 -  11
        D4 = INT(RND * &h10) + &h86      '134 - 150
        D9 = INT(RND * &h02) + &h35e     '862 - 864
        '==========================================
        ' Atr glich point search range

       if atrlock = 0 then
        D7 = INT(RND * &h04) + &h1d   ' 29 -  33
        D8 = INT(RND * &h04) + &h38   ' 56 -  60
        D1 = INT(RND * &h5e) + &ha0   '165 - 191
        D5 = INT(RND * &h02) + &h25d  '605 - 607
        D6 = INT(RND * &h07) + &h36   ' 54 -  61

    end if

    call ProgUpdate(kp,atrlock)

    sc.verbose = 0
    sc.write("A1")
    delay(10)

    if Chk4Card() = 0 then
        BootCard4=0
        Exit Function
    end if

    delay(30)

    sc.write("B0" & HexString(D1,02))
    sc.write("0f1f0120" & HexString(D5,4) & "0c" & HexString(D7,2) & "20" & HexString(D6,4) & "0d00" & HexString(D8,2) & "0000")

    Sc.Read(&h02)

    cter=cter+1
    cnt=0
    Sc.Write("028000")
    if Sc.Read(&h02) = 2 then
         cnt = sc.getbyte(1)
    if cnt = 1 then sc.read(1)
    end if

    if cter > 75 then
        glcnt = glcnt + 1
        if glcnt = 24 then
          glcnt = 0
          call RndGr()
        end if
        cter = 0
        atrlock = 0
    end if

    if cnt > 0 then
       kp=kp+1
       if kp >33 then kp = 33
        sc.print "============================================"&VbCr&"ATR"&VbCr
         for b = 0 to 10
         Sc.Write("028000")

         if Sc.Read(&h02) = 2 then
            cnt = sc.getbyte(1)
         else
            cnt = 0
         end if

         if cnt > 0 then
            cnt = sc.read(cnt)
            kk=sc.getbyte(0)
            if kk = &h38 then
               sc.print "38 "
               Sc.Write("028000")
               cnt = 0
               if Sc.Read(&h02) = 2 then
                   cnt = sc.getbyte(1)
                   if(cnt = 0) then exit for
                      Sc.Read(cnt)
                      if(sc.getbyte(0)) = &hb0 then
                         sc.print "B0" & VbCr & "Attempting to install bootloader "
                         d0=d0+1
                         katr=1
                         cter = 0
                         glcnt = 0
                         atrlock =1
                         exit for
                       end if
                    end if
              end if
         end if

      sc.print HexString(kk,2) &" "
      next
      sc.print VbCr &"============================================"&VbCr
      'sc.print VbCr & cter & VbCr

    if katr = 1 then
       sc.write("B0"  & HexString(D4,02))
       sc.write("071f800d" & HexString(D3,02)& HexString(D2,02)&"0000")
       if Sc.Read(&h02) > 1 then
          cnt = sc.getbyte(1)
       else
          cnt = 0
       end if

       if cnt > 0 then
          cnt = sc.read(cnt)
          for b = 0 to cnt - 1
          next

          Sc.Write("31eeFFFFfed18d52E0FD2266E1B9E17201CF725f0772FF14C5E2AB0100C3DA07F88C0100FFFFFFFFFFFFFFFFFFFFFFFF0000")
          if Sc.Read(&h02)<2 then Sc.Read(&h02)
             Sc.Write("11c060200350042001500320" & HexString(D9,04) & "0d010000")
             Sc.Read(&h02)

          for b = 0 to 8
            Sc.Write("028000")
                        if Sc.Read(&h02) = 2 then
                cnt = sc.getbyte(1)
            else
                cnt = 0
            end if

          if cnt > 0 then
             cnt = sc.read(cnt)
             kk=sc.getbyte(0)
             if kk = &h66 then
                Sc.Write("028000")
                cnt = 0
                if Sc.Read(&h02) = 2 then
                   cnt = sc.getbyte(1)
                   if(cnt = 0) then exit for
                      Sc.Read(cnt)
                      if(sc.getbyte(0)) = &h99 then
                         boot=1
                         sc.print VbCr & "Bootloader installed and active!" & VbCr
                         sc.print "After " & d0 & " tries to activate bootloader" &VbCr
                         exit for
                      end if
                    end if
                 end if
             else
                exit for
          end if

         next

        if boot = 1 then
           Sc.Write("021500")
           Sc.Read(2)
           Sc.Write("42FF225272FF14E1E2D007E2D029E2D02A77800716753F07D307F75011E29B2A70012ADA07F78E013A00D7D307D8078ECEFBD40770012ADA07F300C6F76211F7631100")
           Sc.Read(2)
           Sc.Write("21DE8E0149F76011F76111881c931270FF1203FBF70011728512DA12FDF70011F900")
           Sc.Read(2)
           BootCard4=1
           Exit Function
         end if
       end if
     end if
   else
    kp=kp-1
    if kp<1 then kp=1
   end if
loop

End Function


Sub RndGr

    Dim g1,g2,g3,g4,g5,g6
    Dim dly,v

RANDOMIZE TIMER

  sc.print VbCr & "Random gliching the card to whip it into shape" & VbCr
 sc.verbose = false

  for v = 1 to 800
    g1 = INT(RND * &hFF)
    g2 = INT(RND * &hFF)
    g3 = INT(RND * &hFF)
    g4 = INT(RND * &hFF)
    g5 = INT(RND * &hFF)
    g6 = INT(RND * &h4F) + &h80
    dly= INT(RND * &h200)

   ' sc.write("B0" & HexString(g6,2))
'
    sc.write("111f0120" & HexString(dly,4) & "0c" & HexString(g1,2) & "0c" & HexString(g2,2) & "0a" & "0c" & HexString(g3,2) & "0c" & HexString(g4,2) & "0c" & HexString(g5,2) & "00")
    sc.read(2)
  next

End Sub

Sub CardIsLooped ()
Sc.MsgBox("Card is not returning an ATR." &VbCr & "The card may not be fully Inserted" & VbCr &" or the card contacts may be dirty." & VbCr & "If everything is ok then the card is looped"&VbCr& "You must Unloop the card before using this option ")

End Sub




''''''''''''''''''''''''''''''Unlooping
'Bootcard for unlooping
'
Function BootCard5()
Call Card_Reset()
    Dim d0,D1,D2,D3,D4,D5,D6,D7,D8,d9
    Dim cnt,b, RetVal, boot, kk,katr
    Dim atrlock,cter, glcnt, mtries,kp

    RANDOMIZE TIMER

    atrlock=0
    cter=0
    glcnt=0
    mtries = 0
    d0 = 0
    sc.verbose = False

DO
  katr=0
  mtries = mtries + 1
    if mtries = 5000 then
       call RndGr()
       mtries = 0
    end if

    boot = 0
'==============================================
        'vcc + last 2 glitch 4 bootloader
        D2 = INT(RND * &h04) + &h30      ' 48 -  52
        D3 = INT(RND * &h03) + &h08      '  8 -  11
        D4 = INT(RND * &h10) + &h86      '134 - 150
        D9 = INT(RND * &h02) + &h35e     '862 - 864
        '==========================================
        ' Atr glich point search range

       if atrlock = 0 then
        D7 = INT(RND * &h04) + &h1d   ' 29 -  33
        D8 = INT(RND * &h04) + &h38   ' 56 -  60
        D1 = INT(RND * &h5e) + &ha0   '165 - 191
        D5 = INT(RND * &h02) + &h25d  '605 - 607
        D6 = INT(RND * &h07) + &h36   ' 54 -  61

    end if

    call ProgUpdate(kp,atrlock)

    sc.verbose = 0
    sc.write("A1")
    delay(10)

    if Chk4Card() = 0 then
        BootCard5=0
        Exit Function
    end if

    delay(30)

    sc.write("B0" & HexString(D1,02))
    sc.write("0f1f0120" & HexString(D5,4) & "0c" & HexString(D7,2) & "20" & HexString(D6,4) & "0d00" & HexString(D8,2) & "0000")

    Sc.Read(&h02)

    cter=cter+1
    cnt=0
    Sc.Write("028000")
    if Sc.Read(&h02) = 2 then
         cnt = sc.getbyte(1)
    if cnt = 1 then sc.read(1)
    end if

    if cter > 75 then
        glcnt = glcnt + 1
        if glcnt = 24 then
          glcnt = 0
          call RndGr()
        end if
        cter = 0
        atrlock = 0
    end if

    if cnt > 0 then
       kp=kp+1
       if kp >33 then kp = 33
        sc.print "============================================"&VbCr&"ATR"&VbCr
         for b = 0 to 10
         Sc.Write("028000")

         if Sc.Read(&h02) = 2 then
            cnt = sc.getbyte(1)
         else
            cnt = 0
         end if

         if cnt > 0 then
            cnt = sc.read(cnt)
            kk=sc.getbyte(0)
            if kk = &h38 then
               sc.print "38 "
               Sc.Write("028000")
               cnt = 0
               if Sc.Read(&h02) = 2 then
                   cnt = sc.getbyte(1)
                   if(cnt = 0) then exit for
                      Sc.Read(cnt)
                      if(sc.getbyte(0)) = &hb0 then
                         sc.print "B0" & VbCr & "Attempting to install bootloader "
                         d0=d0+1
                         katr=1
                         cter = 0
                         glcnt = 0
                         atrlock =1
                         exit for
                       end if
                    end if
              end if
         end if

      sc.print HexString(kk,2) &" "
      next
      sc.print VbCr &"============================================"&VbCr
      'sc.print VbCr & cter & VbCr

    if katr = 1 then
       sc.write("B0"  & HexString(D4,02))
       sc.write("071f800d" & HexString(D3,02)& HexString(D2,02)&"0000")
       if Sc.Read(&h02) > 1 then
          cnt = sc.getbyte(1)
       else
          cnt = 0
       end if

       if cnt > 0 then
          cnt = sc.read(cnt)
          for b = 0 to cnt - 1
          next

          Sc.Write("31eeFFFFfed18d52E0FD2266E1B9E17201CF725f0772FF14C5E2AB0100C3DA07F88C0100FFFFFFFFFFFFFFFFFFFFFFFF0000")
          if Sc.Read(&h02)<2 then Sc.Read(&h02)
             Sc.Write("11c060200350042001500320" & HexString(D9,04) & "0d010000")
             Sc.Read(&h02)

          for b = 0 to 8
            Sc.Write("028000")
                        if Sc.Read(&h02) = 2 then
                cnt = sc.getbyte(1)
            else
                cnt = 0
            end if

          if cnt > 0 then
             cnt = sc.read(cnt)
             kk=sc.getbyte(0)
             if kk = &h66 then
                Sc.Write("028000")
                cnt = 0
                if Sc.Read(&h02) = 2 then
                   cnt = sc.getbyte(1)
                   if(cnt = 0) then exit for
                      Sc.Read(cnt)
                      if(sc.getbyte(0)) = &h99 then
                         boot=1
                         sc.print VbCr & "Bootloader installed and active!" & VbCr
                         sc.print "After " & d0 & " tries to activate bootloader" &VbCr
                         exit for
                      end if
                    end if
                 end if
             else
                exit for
          end if

         next

        if boot = 1 then
           Sc.Write("021500")
           Sc.Read(2)
           Sc.Write("42FF225272FF14E1E2D007E2D029E2D02A77800716753F07D307F75011E29B2A70012ADA07F78E013A00D7D307D8078ECEFBD40770012ADA07F300C6F76211F7631100")
           Sc.Read(2)
           Sc.Write("21DE8E0149F76011F76111881c931270FF1203FBF70011728512DA12FDF70011F900")
           Sc.Read(2)
           BootCard5=1
           Exit Function
         end if
       end if
     end if
   else
    kp=kp-1
    if kp<1 then kp=1
   end if
loop

End Function


Sub RndGr

    Dim g1,g2,g3,g4,g5,g6
    Dim dly,v

RANDOMIZE TIMER

  sc.print VbCr & "Random gliching the card to whip it into shape" & VbCr
 sc.verbose = false

  for v = 1 to 800
    g1 = INT(RND * &hFF)
    g2 = INT(RND * &hFF)
    g3 = INT(RND * &hFF)
    g4 = INT(RND * &hFF)
    g5 = INT(RND * &hFF)
    g6 = INT(RND * &h4F) + &h80
    dly= INT(RND * &h200)

   ' sc.write("B0" & HexString(g6,2))
'
    sc.write("111f0120" & HexString(dly,4) & "0c" & HexString(g1,2) & "0c" & HexString(g2,2) & "0a" & "0c" & HexString(g3,2) & "0c" & HexString(g4,2) & "0c" & HexString(g5,2) & "00")
    sc.read(2)
  next

End Sub

Sub CardIsLooped ()
Sc.MsgBox("Card is not returning an ATR." &VbCr & "The card may not be fully Inserted" & VbCr &" or the card contacts may be dirty." & VbCr & "If everything is ok then the card is looped"&VbCr& "You must Unloop the card before using this option ")

End Sub

Function ShowAtr()

    Dim cnt,tmp,b,Msg

    Msg="finished!"
    tmp=""

    sc.write("0610010e109300")

    if Sc.Read(&h02) > 1 then
        cnt = sc.getbyte(1)
    else
        cnt = 0
    end if
    tmp="Card Write Successful!"+VbCr+"ATR Returned:"+VbCr
    if cnt > 0 then
        cnt = sc.read(cnt)

    for b = 0 to cnt -1
      tmp=tmp & HexString(sc.getbyte(b),2) & " "
    next
      sc.print VbCr & tmp & VbCr
      cnt  = Sc.ButtonBox(tmp, 0, Msg, "Ok")
    else
    tmp=""
    tmp=tmp+"Card did not return an ATR"+VbCr+"Try to unloop the card again"+VbCr
    tmp=tmp+"This happens sometimes when the card"+VbCr
    tmp=tmp+"doesn't take the eeprom write"
    cnt = Sc.ButtonBox(tmp, 0,Msg , "Ok")

    end if

End Function

Sub ProgUpdate(pg,atrlock)

    Dim i
    Dim Msg

    Msg="ATR Fun Meter"

    if atrlock = 1 then
      Msg=Msg+VbCr+VbCr+"ATR Fun Meter on high!."
    else
      Msg=Msg+VbCr+VbCr+"Attempting to lock onto ATR."
    end if

    Call Sc.ProgressBox(Msg,pg,33,"Ultra UL")

End Sub